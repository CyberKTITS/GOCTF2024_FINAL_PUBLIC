'''
Для начала распишем уравнения ECDSA:

k1*s1 = m1 + r1*d mod p

k2 =k1*s1
k2*s2 = m2 + r2*d mod p

k2*s2= k1*s1*s2 = s2*(m1 + r1*d )  mod q
s2*(m1 + r1*d ) = m2 + r2*d  mod q
как итог получаем
s2*m1+ (r1*s2-r2)*d -m2 - q*t = 0

d - 80 бит
m1 - 72 bit
m2 - 104 bit
t ~ r*s*d/q = 256*2+80-256 = 336 bit
Нам нужно восстановить m2.

Слишком много переменных имеют размер меньше q. Заставляет задуматься над использованием решетки, которая позволяет находить маленькие корни уравнений. Если не знаете что это, то почитайте и порешайте на cryptohack.org , т.к. это гигабазовая техника. 
Итак, составим решетку аналогично решению проблемы с рюкзаком.
s2*(m1 1 0 0 0) + (r1*s2-r2)*(d 0 1 0 0) + (m2) * (-1 0 0 1 0) + (-q 0 0 0 1) = (0 m1 d m2 t)  
И получим абсолютный мусор, т.к. все переменные в желаемом векторе достаточно большие: 2^80,2^336, ... Алгоритм LLL просто найдет вектор в решетке меньше этого.  
Надо бы уменьшить результирующий вектор, поэтому, используя полученные ранее оценки, давайте получим вектор (0 m1/2^72 d/2^80 m2/2^104 t/2^336). 
Его размер sqrt(0 +1 + 1 + 1 +1) =2, что просто прекрасно. 
Техника классическая, почитать можно тут: http://jgeralnik.github.io/writeups/2021/08/12/Lattices/
'''

r1,s1= 0x78fee26be76d003b65246a4ba15124efd604ac080a39ae85b30b9217410aedfd , 0xf3e8dfede69f669afd26b7ecba3f966741530e59a96d7b0b840ad1c4d89f4368
r2,s2= 0xbf616947bbc381c7661cefb2eba9c86b35a77a4b623313b9d48d157e6ce919ed , 0x50afd8bea25877cb3f76eefcb077f4ba680e3cf8a6c3e28c0aebac7b75aee789

q = 115792089210356248762697446949407573529996955224135760342422259061068512044369

L = Matrix([
    [s2,                1/2^72,0,0,0],
    [int((r1*s2-r2)%q), 0,1/2^80,0,0],
    [-1,                0,0,1/2^104,0],
    [-q,                0,0,0,1/2^336],
]).LLL() # 0            m1 d m2 t

for zero, m1,d,m2,t in L:
    print(m2 * 2^104)

'''
6044953606986220647290824303652 # а вот и флаг: `LLLmoment-$$$`
14634903509332673760695483015660
1
-17400296386500808101721130119571
'''
