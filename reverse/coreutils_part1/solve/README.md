Отличие этого таска от второй части - вы могли просто отдебагать и прочитать main, не задумываясь о диффе. Второй таск без него вы не решили бы.

Нам дан стрипнутый и запатченный бинарь утилиты yes из пакета coreutils, о чем сказано в описании таска.
Вместо бесконечного вывода `argv[1]` он выводит какую-то его перестановку, 512 байт которой нам дают в `output.txt` и просят восстановить введеный туда флаг. 
Для дифа я буду использовать https://github.com/joxeankoret/diaphora, дабы найти патч.
Скомпилируем [coreutils-9.5.tar.xz](https://ftp.gnu.org/gnu/coreutils/coreutils-9.5.tar.xz) с помощью
```bash
./configure
make all
make src/yes
```
(Возможно ужасный вариант компиляции, но я не нашел лучше)
Так вот, в диафору подгружаем две базы и жмем diff

![](files/Pasted%20image%2020240527102314.png)

Видим, что одна функа отличается сильнее остальных, это еще и main:

![](files/Pasted%20image%2020240527102048.png)

Прожав `diff assembly`, видим, что львиная доля патча - изменение имен функций.

![](files/Pasted%20image%2020240527102746.png)

Самое интересное находится внизу функции:

![](files/Pasted%20image%2020240527103354.png)

Теперь давайте прожмем `import all` в `best matches` и импортируем все функции из `partial matches` кроме `main`.
`Diff-pseudocode` покажет следующее (на самом деле отличается только выделенное синим):

![](files/Pasted%20image%2020240527103648.png)

Теперь остается только осознать происходящее. 
Здесь код выглядит как 
```c
v21 = sub_5540(0LL);
srand(v21);
v22 = rand();
srand(v22 % 256);
while ( 1 )
{
	v23 = rand();
	full_write(1, &v6[v23 % v12], 1uLL);
}
```
Плюсом в оригинальном бинаре у нас
```c
  while ( v12 == full_write(1, v6, v12) )
    ;
  v21 = dcgettext(0LL, "standard output", 5);
  v22 = __errno_location();
  error(0, *v22, v21);
  return 1;
```
Прочитаем `src/yes.c`:
```c
  while (full_write (STDOUT_FILENO, buf, bufused) == bufused)
    continue;
  error (0, errno, _("standard output"));
  main_exit (EXIT_FAILURE);
```
Получается, `v6` - `buf`, `v12` - `bufused`.
Давайте попатчим `src/yes.c` и посмотрим что это такое. Окажется, что это просто `argv[1]+'\n'` повторенное, чтобы `buf` был размера `bufused`.
Прописав в бинарь что-то вроде
```c
  printf("%d\n", bufused);
  return 0;
```
Можно будет вытащить bufused, так и сделаем скриптом на питоне для каждого кол-ва символов:
```python
In [8]: lens = [
   ...:     int(subprocess.check_output(["./src/yes", "1" * i]).strip()) for i in range(0, 100)
   ...: ]

In [9]: lens
Out[9]:
[8192,
 8192,
 8190,
 8192,
 ...
```
Не забываем, что в конце сообщения добавляется еще и `\n`!
В итоге наш бинарь делает что-то вроде
```c
srand(rand() % 256);
while ( 1 )
{
	full_write(stdout, &buf[rand()% bufused], 1uLL);
}
```
Т.е. просто выбирает случайный символ из строки `(argv[1]+'\n')*x` 512 раз.
Осталось угадать сид рандома (всего 256 вариантов) и длину флага.
При переборе можно
а) знать что если мы уже узнали символ флага на позиции `x`,то если мы далее опять угадаем символ на этой позиции, то они должны совпасть
б) если встречаем `\n`, то он должен стоять на позиции `flag_len-1 mod flag_len`
Код решения можете найти в `sol.cpp`.